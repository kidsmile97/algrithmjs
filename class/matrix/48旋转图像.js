/**
48. 旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

1 2 3
4 5 6
7 8 9

=>

7 4 1
8 5 2
9 6 3

1   2  3  4  5  7
6   7  8  9 10  7
11  12 13 14 15 7
16  17 18 19 20 7
21  22 23 24 25 7
7   7  7  7  7  7

分析：
要求空间复杂度 O(1)

1. 先分析问题的本质，对于不熟悉的内容需要举例分析其本质找出规律，要求旋转 90 度，n = 3 时有如下具体表现
(0, 0) => (0, 2)
(0, 1) => (1, 2)
(0, 2) => (2, 2)

(1, 0) => (0, 1)
(1, 1) => (1, 1)
(1, 2) => (2, 1)

(2, 0) => (0, 0)
(2, 1) => (1, 0)
(2, 2) => (2, 0)

特性一：
n 为奇数时，存在 (n>>1, n>>1) 的中位置，旋转后位置不变
n 为偶数时，存在中心矩阵 (n>>1, n>>1)\(n>>1 - 1, n>>1 - 1)

特性二：
旋转是按圈影响的，每一圈的位置旋转后仍在该一圈，不会影响其他圈。比如最外圈的位置，旋转后仍然都在最外圈，算法应该考虑一圈圈由外而内的操作

特性三：
由圈特性可知，每一圈都有两行、两列、4个角，中心圈特别，或只有一个中心位置，或中心圈是 2 * 2 矩阵，行列角共4个数

旋转后，行变成列，列变成行

以上分析全是辣鸡，错误分析，请忽略！！！！！

看答案后分析：

旋转后就是行变成列，n * n 矩阵旋转后，第 i 行 => 第 (n-i-1) 列

m(i, j) = m( j , n-i-1 )

思考：如何在 O(1) 的空间下完成转换

设计循环，按圈循环替换即可，只需要一个 temp 保存当前被替换位置数据

m( i, j ) => m( j , n-i-1 )
m( j, n-i-1 ) => m( n-i-1, n-j-1 )
m( n-i-1, n-j-1 ) => m( n-j-1, i )
m( n-j-1, i ) => m( i, j )

 */

function rotate(matrix) {
  const n = matrix.length;
  for(let i = 0; i < n>>1; i++) {
    for (let j = i; j < n-i-1; j++) {
      let temp = matrix[i][j];
      matrix[i][j] = matrix[n-j-1][i];
      matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
      matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
      matrix[j][n-i-1] = temp;
    }
  }
};

module.exports = rotate;
