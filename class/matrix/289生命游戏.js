/**
289.生命游戏

根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。

给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。
每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：

1. 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
2. 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；
3. 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
4. 如果死细胞周围正好有三个活细胞，则该位置死细胞复活；

下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。

目标：
根据规则更新矩阵状态

分析规则：
1. 每个位置的状态与周围位置状态相关，而且这种影响是同时的，即下一状态是符合当前状态规则即可，与变化后的状态无关
即 a 位置对 b 位置的影响是以当前状态为准，与 a 变化后的状态无关
2. 规则核心就是计算周围8个位置活细胞数量
活细胞 < 2，细胞死亡
活细胞 == 2，细胞状态不变
活细胞 == 3，细胞活
活细胞 > 3，细胞死

根据当前状态逐个计算当前各自状态即可(暴力解法)

时间复杂度 O(mn) 空间复杂度 O(mn)

唯一优化方案：优化空间复杂度，定义新的状态代表复合状态，这样可以实现直接在原属组修改
eg
0: 原死现死
1: 原生现生
2: 原死现生
3: 原生现死
这样就可以即知道当前状态，也可以知道之前状态

更高速度算法，使用位运算：同时优化计算和空间，但原则上时间复杂度仍然是 O(mn)，遍历次数不可能少于这个
 */

function gameOfLife(board) {
  const m = board.length;
  const n = board[0].length;
  const result = new Array(m).fill(0).map(() => new Array(n).fill(0))
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      let alive = 0;
      // 求和活细胞数量
      if ( i-1 > -1) {
        alive += board[i-1][j]
        if (j-1 > -1) {
          alive += board[i-1][j-1]
        }
        if (j+1 < n) {
          alive += board[i-1][j+1]
        }
      }
      if (i+1 < m) {
        alive += board[i+1][j]
        if (j-1 > -1) {
          alive += board[i+1][j-1]
        }
        if (j+1 < n) {
          alive += board[i+1][j+1]
        }
      }
      if (j-1 > -1) {
        alive += board[i][j-1]
      }
      if (j+1 < n) {
        alive += board[i][j+1]
      }
      // 计算状态
      if (alive < 2) {
        result[i][j] = 0
      } else if (alive === 2) {
        result[i][j] = board[i][j]
      } else if (alive === 3) {
        result[i][j] = 1
      } else {
        result[i][j] = 0
      }
    }
  }
  // 更新状态
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      board[i][j] = result[i][j]
    }
  }
}

