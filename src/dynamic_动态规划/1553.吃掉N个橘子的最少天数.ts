/**
1553. 吃掉 N 个橘子的最少天数

厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子：

吃掉一个橘子。
如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。
如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。
每天你只能从以上 3 种方案中选择一种方案。

请你返回吃掉所有 n 个橘子的最少天数。

输入：n = 10
输出：4
解释：你总共有 10 个橘子。
第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。
第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）
第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。
第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。
你需要至少 4 天吃掉 10 个橘子。

## 分析

1. 轻易可知，1 < n/2 < 2*(n/3)

2. 上一次选择方案会影响下一次方案的选择，如何判断能否使用贪心算法？

## 动态规划

f(i) 表示吃掉 i 个橘子的最少天数

f(1) = 1
f(i) = i % 6 == 0 ? min{ f(i - 1), f(i/2), f(i - 2*(i/3)) } + 1
f(i) = i % 3 == 0 ? min{ f(i - 1), f(i - 2*(i/3)) } + 1
f(i) = i % 2 == 0 ? min{ f(i - 1), f(i/2) } + 1
f(i) = f(i - 1) + 1

问题：时间复杂度 O(n)，空间复杂度 O(n)，n 很大时会超时溢出

## 如何优化这个动态规划过程？

 */

// 动态规划
function _minDays(n: number): number {
	let dayi: number[] = [0, 1];
	for (let i = 2; i <= n; i++) {
		if (i % 6 == 0) {
			dayi.push(Math.min(dayi[i - 1], dayi[i / 2], dayi[i - 2 * (i / 3)]) + 1);
		} else if (i % 3 == 0) {
			dayi.push(Math.min(dayi[i - 1], dayi[i - 2 * (i / 3)]) + 1);
		} else if (i % 2 == 0) {
			dayi.push(Math.min(dayi[i - 1], dayi[i / 2]) + 1);
		} else {
			dayi.push(dayi[i - 1] + 1);
		}
	}
	return dayi[n];
}

/**
动态规划 + 数学分析

动态规划设计计算过程

数学分析简化计算细节

## 动态规划 + 贪心 =》自顶向下的动态规划

动态规划的核心是状态转移，使得前面的计算结果服务于后面的计算结果

本题经过数学性质分析后，可以使用贪心的思想，自顶向下寻找需要计算的子状态，无关的子状态可以忽略，从而达到优化的结果

## 数学分析

对于
吃1个（操作1）
吃1/2（操作2）
吃2/3（操作3）
这三种情况，轻易可证得，操作2、操作3 在 n > 1 时永远大于操作1，所以可以应用贪心的思想

尽量选择吃 1/2 或者 2/3，而不选吃一个

所以有

f(1) = 1
f(i) = i % 2 + 1 + f( floor(i/2) )
// 执行 i % 2 次操作1后，一定是 2 的倍数，+ 1 是执行操作2，f( floor(i/2) ) 是剩余的执行次数
f(i) = i % 3 + 1 + f( floor(i/3) )
// 执行 i % 3 次操作1后，一定是 2 的倍数，+ 1 是执行操作3，f( floor(i/3) ) 是剩余的执行次数

 */
function minDays(n: number): number {
	const map = new Map<number, number>();
	map.set(1, 1);
	map.set(0, 0);
	const getn = (i: number): number => {
		if (map.has(i)) {
			return map.get(i)!;
		}
		map.set(i, Math.min((i % 2) + 1 + getn(i >> 1), (i % 3) + 1 + getn(Math.floor(i / 3))));
		return map.get(i)!;
	};
	return getn(n);
}

export default minDays;
