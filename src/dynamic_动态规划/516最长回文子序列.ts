/**
516. 最长回文子序列

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

分析：

## 先了解确定定义

回文序列：即正序倒序相同的字符串序列

子序列：由题目定义可知，子序列、子串并不完全相同，子串是从字符串中截取一段，不改变顺序；子序列是删除某些内容得到的剩余不改变前后顺序拼接一起

## 回文串的判定方法

快慢指针应该是最快的判断方法，O(n) + O(1)

## 题目分析
1. 最小结果是 1，因为单个字符的序列是回文序列
2. 最大结果是 s.len ，不做任何删减的子序列
3. 

## 暴力解法

1. 获取所有子序列
2. 判断回文
3. 得到最大长度

因为目标是最大长度，可以在获取子序列的过程中，考虑剪枝部分：子序列长度 <= 当前得到的最大长度回文子序列

换言之，应该从最长子序列开始一步步缩短子序列长度，第一个找到的回文序列就是最长的，后面部分都不用寻找了

时间复杂度是 O(n!) 级别的，非常高，由子序列的定义可知，长度 n 的字符串有

1 + C(1, n) + C(2, n) + C(3, n) + ... + C(n-2, n)

tip: 其中 C(i, n) 是组合公式，意思是从 n 个字符中选择 i 个删除，由 C(i, n) = n! / i! * (n-i)!

最差情况是遍历完所有，都不是回文串，最后返回 1

基本上不用尝试，辣鸡得一批

## 换个思路，暴力解法一般都是用来提供思路的，可以优化，或者暴力解法中凸显了问题的什么特点等等，一般都有一点启发作用

没有思路，暴力解法不能提供任何思路。

给问题换个说法，即在 s 中选择 k 个元素，在保持前后相对顺序的前提下组成回文序列，求最大的 k

这个是贪心算法环境下的说法，但是问题明显不合适使用该算法，这个说法也不能提供任何解题思路

## 动态规划

此菜鸡看了题解，简而言之

dp(i, j) 表示 [i, j] 之间最长的回文串长度

那么假设从中间向两边扩展时有如下特性

对于 dp(i-1, j+1)

若 s[i-1] = s[j+1]

则有 dp(i-1, j+1) = dp(i, j) + 2;

若 s[i-1] != s[j+1]

则有 dp(i-1, j+1) = Math.max(dp(i - 1, j), dp(i, j + 1))

 */

function longestPalindromeSubseq(s: string): number {
	const dpres: number[][] = new Array(s.length).fill(0).map(() => new Array(s.length).fill(1));

	const getRes = (i: number, j: number) => {
		if (i > j) return 0;
		return dpres[i][j];
	};

	for (let len = 2; len <= s.length; len++) {
		let i = 0;
		let j = i + len - 1;
		while (j < s.length) {
			if (s[i] == s[j]) {
				dpres[i][j] = getRes(i + 1, j - 1) + 2;
			} else {
				dpres[i][j] = Math.max(getRes(i + 1, j), getRes(i, j - 1));
			}
			i++;
			j++;
		}
	}

	return dpres[0][s.length - 1];
}

export default longestPalindromeSubseq;
