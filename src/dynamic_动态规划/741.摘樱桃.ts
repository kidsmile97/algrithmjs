/**
741. 摘樱桃

给你一个 n x n 的网格 grid ，代表一块樱桃地，每个格子由以下三种数字的一种来表示：

0 表示这个格子是空的，所以你可以穿过它。
1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
-1 表示这个格子里有荆棘，挡着你的路。
请你统计并返回：在遵守下列规则的情况下，能摘到的最多樱桃数：

从位置 (0, 0) 出发，最后到达 (n - 1, n - 1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为 0 或者 1 的格子）；
当到达 (n - 1, n - 1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为 0 ）；
如果在 (0, 0) 和 (n - 1, n - 1) 之间不存在一条可经过的路径，则无法摘到任何一个樱桃。

## 分析

1. 先向下向右行动，动态规划

dp[i, j] = -1 || Math.max(dp[i-1, j], dp[i, j-1]) + grid[i, j]

2. 返回向左向上行动，动态规划

dp[i, j] = -1 || Math.max(dp[i+1, j], dp[i, j+1]) + grid[i, j]

结合1、2，即相当于从 (0, 0) 到 (n-1, n-1) 走两遍能拿到的最多的樱桃

tip：需要记录通过路径，把已经通过的格子 cherry 置为 0

FALSE: 请注意以下特别的例子，说明去的路径会影响回的情况

0 1 0 N
1 N 1 0
1 1 1 N
1 1 1 0

去的路径有两条都是 5 的路径

但是回的时候两条路分别是 2 和 3

答案是 5 + 3 = 8，即去的时候需要排除其中一条路径，怎么排除？

## tm 的好答案，定义成两个人一起出发而不是一个人出发两遍，就可以优雅的用动态规划完成一去一回的路径



 */
function cherryPickup(grid: number[][]): number {
	const n = grid.length;
	let res = new Array(n).fill(0).map(() => new Array(n).fill(0));
	res[0][0] = grid[0][0];
	// 初始化第一行第一列
	for (let i = 1; i < n; i++) {
		res[i][0] = grid[i][0] == -1 || res[i - 1][0] == -1 ? -1 : res[i - 1][0] + grid[i][0];
		res[0][i] = grid[0][i] == -1 || res[0][i - 1] == -1 ? -1 : res[0][i - 1] + grid[0][i];
	}
	for (let i = 1; i < n; i++) {
		for (let j = 1; j < n; j++) {
			if (grid[i][j] == -1) {
				res[i][j] = -1;
			} else {
				const max = Math.max(res[i - 1][j], res[i][j - 1]);
				res[i][j] = max == -1 ? -1 : max + grid[i][j];
			}
		}
	}
	// 寻路置0
	if (res[n - 1][n - 1] == -1) {
		return 0;
	}
	return res[n - 1][n - 1];
}

export default cherryPickup;
