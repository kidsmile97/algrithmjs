/**
1883. 准时抵达会议现场的最小跳过休息次数

给你一个整数 hoursBefore ，表示你要前往会议所剩下的可用小时数。
要想成功抵达会议现场，你必须途经 n 条道路。
道路的长度用一个长度为 n 的整数数组 dist 表示，其中 dist[i] 表示第 i 条道路的长度（单位：千米）。
另给你一个整数 speed ，表示你在道路上前进的速度（单位：千米每小时）。

当你通过第 i 条路之后，就必须休息并等待，直到 下一个整数小时 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。

例如，如果你通过一条道路用去 1.4 小时，那你必须停下来等待，到 2 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 2 小时，就无需等待，可以直接继续。
然而，为了能准时到达，你可以选择 跳过 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。

例如，假设通过第 1 条道路用去 1.4 小时，且通过第 2 条道路用去 0.6 小时。跳过第 1 条道路的休息时间意味着你将会在恰好 2 小时完成通过第 2 条道路，且你能够立即开始通过第 3 条道路。
返回准时抵达会议现场所需要的最小跳过次数 ，如果 无法准时参会 ，返回 -1 。

## 题目信息汇总

hoursBefore: 可用小时数

speed: 时速

dist: 道路数组（距离）

假设没有跳过机制，则到达时间 h，有

h = dist.reduce((pre, cur) => pre += Math.ceil(cur / speed), 0)

## 优化机制

roadDis / speed 会出现小数，速度放慢至 1，距离=时间，总和最后再除以 speed 即可得到真正的时间，符合结合率（除法 = 乘法）

h = T(roadDis / speed) => T(road) / speed

## 示例分析

dist = [1,3,2]  speed = 4  h = 2

通过第 i 条道路，余量表示需要休息时间 l 才能再出发
1. 时间t1: d(1) = 1，余量l(1): speed - t(1) % speed = 4 - 1 = 3
2. 时间t2: t(1) + l(1) + d(2) = 1 + 3 + 3 = 7，余量l(2): speed - t(2) % speed = 4 - 3 = 1
3. 时间t3: t(2) + l(2) + d(3) = 7 + 1 + 2 = 10，余量 null
=>
t(3) = t(2) + l(2) + d(3) = t(1) + l(1) + d(2) + l(2) + d(3) =  d(1) + l(1) + d(2) + l(2) + d(3)

显而易见的是，影响最终到达时间的实际上只是余量，核心问题是余量是向后影响的，前面的余量会对后面所有的余量产生影响

对于动态规划来说，由于向后影响的缘故，当前最佳通过方案 ≠ 下一条路的最佳方案的前置方案

对于贪心来说，不存在最优子结构性质，只有整体最优，无法使用

最终时间 t(3) / speed = 2.5

## 问题分析

由于前面的任意一个余量都会影响后面的进程，每次都有跳过不跳过 2 种情况，暴力解法复杂度 2^n

对于这种问题，一定是需要转变思路，寻找到合适的切入点，切开这种联系，才能达到简化问题的目的

如何切开这种联系？

切不开，但是从【示例分析】可以看出，后者和前者是存在联系的，t(3) 和 t(2) 相关

动态规划的一个重要功能 => 计算路径记忆，不需要最优，只单纯记忆曾经的计算结果，这样也可以优化问题算法

所以本题动态规划就有了操作空间。

## 根据示例分析的等式，设计状态转移方程

1. 动态规划的核心：找到两种状态的等式关系

(1) 如何设定某种状态？

- 根据最终问题假定状态。
因为无论设计什么，最终都要为问题结果而服务的，所以动态规划的中间状态肯定需要为结果服务，所以没有思路时应当从最终问题出发。

- 分析最终问题，可知的几个变量如下
问题：通过第 i 条路，跳过 j 次，需要时间 h[i][j]（求最小的 j ，使得 h < (?)）

(2) 状态和状态之间怎么联系？

因为当固定 i，固定 跳过 j 次，那么就存在一个定值，使得该条件下有最小用时，出现了最优子结构的特点

即 通过 i 条路，跳过了 j 次，总花费时间 h[i][j]，而且 i > j，比如第 3 条路最多只能跳过两次
此时对于 i-1 条路，有两种可能，
+ 在第 i-1 条路跳过了，然后通过了第 i 条路
+ 在第 i-1 条路没有跳过，休息，然后通过了第 i 条路

有 h[i][j] = h[i-1][j-1] + dist[i] || h[i-1]h[j] + (speed - h[i-1]h[j] % speed) + dist[i]

(3) 确定初始状态

h[0][0] = dist[0]
h[1][0] = h[0][0] + dist[1]
h[1][1] = h[0][0] + (speed - h[0]h[0] % speed) + dist[1]
h[2][0] = h[1][0]

 * 
 */

function minSkips(dist: number[], speed: number, hoursBefore: number): number {
	const size = dist.length;
	const dp: number[][] = new Array(size).fill(0).map(() => new Array(size).fill(0));
	dp[0][0] = dist[0];
	for (let i = 1; i < size; i++) {
		let rest = dp[i - 1][0] % speed;
		rest = rest > 0 ? speed - rest : 0;
		dp[i][0] = dp[i - 1][0] + rest + dist[i];
		dp[i][i] = dp[i - 1][i - 1] + dist[i];
	}
	for (let i = 1; i < size; i++) {
		for (let j = 1; j < i; j++) {
			let rest = dp[i - 1][j] % speed;
			rest = rest > 0 ? speed - rest : 0;
			const d1 = dp[i - 1][j] + rest + dist[i];
			const d2 = dp[i - 1][j - 1] + dist[i];
			dp[i][j] = Math.min(d1, d2);
		}
	}
	let times = 0;
	const row = size - 1;
	const hours = hoursBefore * speed;
	while (times < size) {
		if (dp[row][times] <= hours) {
			return times;
		} else {
			times++;
		}
	}
	return -1;
}

export default minSkips;
